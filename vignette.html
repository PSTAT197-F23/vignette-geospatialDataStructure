<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Yibo Liang, Pippa Lin, Chris Zhao">
<meta name="dcterms.date" content="2023-12-03">

<title>An Introdution to Geospatial Data Structures</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="vignette_files/libs/clipboard/clipboard.min.js"></script>
<script src="vignette_files/libs/quarto-html/quarto.js"></script>
<script src="vignette_files/libs/quarto-html/popper.min.js"></script>
<script src="vignette_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="vignette_files/libs/quarto-html/anchor.min.js"></script>
<link href="vignette_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="vignette_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="vignette_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="vignette_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="vignette_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">An Introdution to Geospatial Data Structures</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Yibo Liang, Pippa Lin, Chris Zhao </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 3, 2023</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p>In this project, we navigate the geospatial data structures through the <code>sf</code> package in RStudio. First, we focus on a detailed exploration of spatial objects, highlighting their creation and practical applications. We use visualization techniques, exemplifying how to represent clusters as polygons, map U.S. states, and associate species with locations, showing the geospatial data structures in visualization and analysis. Additionally, a brief overview of spatial Poisson modeling is provided on how to model and predict.</p>
</section>
<section id="table-of-contents" class="level2">
<h2 class="anchored" data-anchor-id="table-of-contents">Table of Contents</h2>
<p><a href="#the-sf-package">1. The “sf” Package</a></p>
<p><a href="#using-sf-objects-to-record-geospatial-polygons">2. Using sf Objects to Record GeoSpatial Polygons</a></p>
<p><a href="#creating-a-2d-polygon-on-real-data">3. Creating a 2D Polygon on Real Data</a></p>
<p><a href="#modeling-with-geospatial-data-spatial-poisson-model">4. Modeling with Geospatial Data: Spatial Poisson Model</a></p>
<p><a href="#conclusion">5. Conclusion</a></p>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>This Vignette provides a comprehensive introduction to geospatial data structures using the “sf” package in R. We begins by introducing basic spatial structures within the “sf” package, including points, lines, and polygons.</p>
<p>We’ll illustrate how to convert vector data into “sf” objects, creating 2D polygons that represent clusters of geographical points. Although many methods of Geospatial Data are complex, we will explore two simple methods: cluster grouping, which condenses data into 2D polygons, and centroid polygons, which separate data points in dense clusters.</p>
<p>A real-world example follows, demonstrating the creation of a 2D polygon map of the United States using “sf” objects. Furthermore, the integration of attributes with geospatial data is demonstrated by associating invasive species <a href="https://www.kaggle.com/datasets/lazaro97/biological-invasions">data</a> with states, allowing for efficient filtering and visualization.</p>
<p>Finally, we will briefly explore modeling with geospatial data, introducing a spatial Poisson model to predict species occurrences. The process involves preparing a spatial weights matrix, building the model, and making predictions based on the spatial Poisson model. However, this process is complex and require massive computing power to execute. Therefore, we leave it to the readers to further explore this topic.</p>
</section>
<section id="the-sf-package" class="level2">
<h2 class="anchored" data-anchor-id="the-sf-package">1. The “sf” Package</h2>
<p>The R-package we will be using for this demonstration is the “sf” package. It adopts the “Simple Features” formal standard, outlining a storage and access model for spatial geometries such as points, lines, and polygons. A geometry is considered simple when it comprises points connected by straight line segments and avoids self-intersections.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(sf)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidymodels)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggmap)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(leaflet)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(concaveman)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="basic-spatial-structures-in-sf" class="level3">
<h3 class="anchored" data-anchor-id="basic-spatial-structures-in-sf">1.1 Basic Spatial Structures in “sf”</h3>
<p>Some of the basic spatial objects that are in the “sf” package for dealing with vector spatial data include:</p>
<ul>
<li><p>Points: 2D or 3D data consisting of a single coordinate or a set of coordinates.</p></li>
<li><p>Lines: A line object is a spaghetti collection of 2D coordinates</p>
<ul>
<li>A Lines object is a list of one or more line objects, for example all the contours at a single elevation.</li>
</ul></li>
<li><p>Polygons: A Polygon object is a spaghetti collection of 2D coordinates with equal first and last coordinates</p>
<ul>
<li>A Polygons object is a list of one or more Polygon objects, for example islands belonging to the same country.</li>
</ul></li>
</ul>
<p><img src="images/geomtry.png" class="img-fluid"></p>
<p>A simple feature object is stored as a “sf” object. The image above is a visualization of the “sf” objects.</p>
</section>
<section id="creating-a-sf-object" class="level3">
<h3 class="anchored" data-anchor-id="creating-a-sf-object">1.2 Creating a “sf” object</h3>
<p>Let’s create an example “sf” line object. A line object is characterized by points in some coordinate space and connected by a chord we call line.</p>
<p>First, we will define the lines themselves with <code>st_linestring()</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>lnstr_sfg1 <span class="ot">&lt;-</span> <span class="fu">st_linestring</span>(<span class="fu">matrix</span>(<span class="fu">runif</span>(<span class="dv">10</span>), <span class="at">ncol=</span><span class="dv">2</span>)) <span class="co"># a line with 10 points</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>lnstr_sfg2 <span class="ot">&lt;-</span> <span class="fu">st_linestring</span>(<span class="fu">matrix</span>(<span class="fu">runif</span>(<span class="dv">10</span>), <span class="at">ncol=</span><span class="dv">2</span>)) <span class="co"># ncol = 2 specifies the dimension</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, we will combine the two lines into a single feature before transforming it into a single “sf” object.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>(lnstr_sfc <span class="ot">&lt;-</span> <span class="fu">st_sfc</span>(lnstr_sfg1, lnstr_sfg2)) <span class="co"># just one feature here</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Geometry set for 2 features 
Geometry type: LINESTRING
Dimension:     XY
Bounding box:  xmin: 0.1050707 ymin: 0.1058156 xmax: 0.9518242 ymax: 0.9687663
CRS:           NA</code></pre>
</div>
</div>
<p>Now that we have 2 lines combined into a single feature, we haven’t actually assigned any meaning to the 2 lines yet. Let’s give them some attributes! Let’s pretend that these two lines are a highway and we they each have an attribute `car_per_hour` describing the number of cars that travels through them every hour.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>dfr <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">id =</span> <span class="fu">c</span>(<span class="st">"hwy1"</span>, <span class="st">"hwy2"</span>),</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>                  <span class="at">cars_per_hour =</span> <span class="fu">c</span>(<span class="dv">78</span>, <span class="dv">22</span>)) </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>(lnstr_sf <span class="ot">&lt;-</span> <span class="fu">st_sf</span>(dfr , lnstr_sfc)) <span class="co"># 2 lines each with an attribute cars_per_hour</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Simple feature collection with 2 features and 2 fields
Geometry type: LINESTRING
Dimension:     XY
Bounding box:  xmin: 0.1050707 ymin: 0.1058156 xmax: 0.9518242 ymax: 0.9687663
CRS:           NA
    id cars_per_hour                      lnstr_sfc
1 hwy1            78 LINESTRING (0.5921889 0.105...
2 hwy2            22 LINESTRING (0.6737138 0.499...</code></pre>
</div>
</div>
<p>Now we have a data-frame that associates an attribute to a spatial structure rather than another data point!</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> lnstr_sf[<span class="st">"id"</span>]) <span class="sc">+</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_minimal</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="vignette_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
</section>
<section id="using-sf-objects-to-record-geospatial-polygons" class="level2">
<h2 class="anchored" data-anchor-id="using-sf-objects-to-record-geospatial-polygons">2. Using sf Objects to Record GeoSpatial Polygons</h2>
<p>With Geospatial Data structures, one can give geographical meaning to their data.</p>
<p><img src="images/800px-RTree-Visualization-3D.svg.png" class="img-fluid"></p>
<p>We will explore two simple ways to record geospatial data. Two dimensional polygons using border data and 2 dimension polygons using centroid data.</p>
<section id="d-polygons-using-vector-border-data" class="level3">
<h3 class="anchored" data-anchor-id="d-polygons-using-vector-border-data">2.1 2D Polygons using Vector (Border) Data</h3>
<p>Now that we understand how to create a sf object; let’s demonstrate an sf object that contains geospatial meaning. Let’s take 3 clusters of vector points a, b, and c and showcase the utility of the sf object.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="vignette_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Looking at the points above, there is clearly some implicit relationship between the point clusters. However, it would be incredibly difficult to identify the clusters if there were more points and more variables.</p>
<p>Location gets increasingly difficult to keep track of as we get higher and higher dimensions in our dataframe. Therefore, instead of keeping every coordinate of the location, we can keep the geometries themselves as objects in the dataframe.</p>
<p>Going back to the previous example, using the sf package, we can then treat these cluster points as coordinate points and draw a polygon. The reason why we call is the border points is that these vectors quite literally draw the borders of the area that encapsulates the data points.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Use the concave pacakge to visualize the sf object after grouping</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> P<span class="sc">$</span>Fr[<span class="dv">1</span>]</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>final_P <span class="ot">&lt;-</span> <span class="fu">lapply</span>(<span class="fu">unique</span>(P<span class="sc">$</span>Fr), <span class="cf">function</span>(x) {</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  group <span class="ot">&lt;-</span> P[P<span class="sc">$</span>Fr <span class="sc">==</span> x, ]</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  conc <span class="ot">&lt;-</span> concaveman<span class="sc">::</span><span class="fu">concaveman</span>(group, <span class="at">length_threshold =</span> <span class="dv">0</span>,</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">concavity =</span> <span class="fl">0.999999</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  conc<span class="sc">$</span>Fr <span class="ot">&lt;-</span> x</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  conc</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>}) <span class="sc">%&gt;%</span> <span class="fu">bind_rows</span>()</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the graph</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(final_P) <span class="sc">+</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="fu">aes</span>(<span class="at">fill =</span> Fr)) <span class="sc">+</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> P, <span class="at">fill=</span><span class="cn">NA</span>, <span class="at">shape=</span><span class="dv">21</span>, <span class="at">size=</span><span class="fl">0.7</span>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="vignette_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The datapoints are recorded as 2D polygons. The graph above gives a visual representation of what the “sf” package is doing to our data structure.</p>
</section>
<section id="d-polygons-using-centroids" class="level3">
<h3 class="anchored" data-anchor-id="d-polygons-using-centroids">2.2 2D Polygons Using Centroids</h3>
<p>The first method is useful for when we want to group data points. The Centroid method is more useful for when we want to separate the data. Consider the following cluster:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate some centroids</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>centroids <span class="ot">&lt;-</span> <span class="fu">st_make_grid</span>(<span class="at">what=</span><span class="st">"centers"</span>) <span class="sc">%&gt;%</span> <span class="fu">st_sf</span>()</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(centroids)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="vignette_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Centroid polygons are useful for when we want to distinguish individual data points in a dense cluster like the one above. We can define a border for each point and we are able to effectively separate the points.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Make a new grid from them</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>cellSize <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>grid <span class="ot">&lt;-</span> (<span class="fu">st_bbox</span>(centroids) <span class="sc">+</span> cellSize<span class="sc">/</span><span class="dv">2</span><span class="sc">*</span><span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>,<span class="sc">-</span><span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">st_make_grid</span>(<span class="at">cellsize=</span><span class="fu">c</span>(cellSize, cellSize)) <span class="sc">%&gt;%</span> <span class="fu">st_sf</span>()</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>() <span class="sc">+</span> <span class="fu">geom_sf</span>(<span class="at">data=</span>grid) <span class="sc">+</span> <span class="fu">geom_sf</span>(<span class="at">data=</span>centroids)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="vignette_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>TL:DR, we have gone over two techniques in storing geospatial data. Cluster grouping condenses the dataframe into 2D polygons; on the other hand, drawing polygons around centroids expands the dataframe into 2D polygons.</p>
</section>
</section>
<section id="creating-a-2d-polygon-on-real-data" class="level2">
<h2 class="anchored" data-anchor-id="creating-a-2d-polygon-on-real-data">3. Creating a 2D Polygon on Real Data</h2>
<p>Using everything we’ve discussed so far, let’s draw a geospatial map. First we will load in a vector of coordinates.</p>
<div class="cell">

</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>us_geo</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 48 × 3
   name        geometry                                                 iso_code
   &lt;chr&gt;       &lt;chr&gt;                                                    &lt;chr&gt;   
 1 Alabama     MULTIPOLYGON (((-88.053375 30.506987, -88.0510879999999… US-AL   
 2 Arizona     POLYGON ((-114.816294 32.508038, -114.814321 32.509023,… US-AZ   
 3 Arkansas    POLYGON ((-94.6178329666013 36.4994141203285, -94.61764… US-AR   
 4 California  MULTIPOLYGON (((-118.604415 33.478552, -118.598783 33.4… US-CA   
 5 Colorado    POLYGON ((-109.060253 38.599328, -109.059541 38.719888,… US-CO   
 6 Connecticut MULTIPOLYGON (((-72.761427 41.242333, -72.759733 41.248… US-CT   
 7 Delaware    MULTIPOLYGON (((-75.565546 39.51485, -75.56174299999999… US-DE   
 8 Florida     MULTIPOLYGON (((-80.176276 25.525054, -80.1739499999999… US-FL   
 9 Georgia     MULTIPOLYGON (((-81.27939099999999 31.30792, -81.277159… US-GA   
10 Idaho       POLYGON ((-117.242675 44.396548, -117.234835 44.399669,… US-ID   
# ℹ 38 more rows</code></pre>
</div>
</div>
<p>What we have just loaded in is a dataframe containing the 48 States (Sorry Hawaii and Alaska) and their latitudes and longitudes of points along their perimeter.</p>
<p>However, a vector of coordinates is hard to interpretate. Therefore, we can convert this vector data into geospatial data by creating a “sf” object.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>SQ_example <span class="ot">&lt;-</span> <span class="fu">st_as_sf</span>(us_geo, <span class="at">wkt =</span> <span class="st">"geometry"</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(SQ_example)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>sf [48 × 3] (S3: sf/spec_tbl_df/tbl_df/tbl/data.frame)
 $ name    : chr [1:48] "Alabama" "Arizona" "Arkansas" "California" ...
 $ geometry:sfc_GEOMETRY of length 48; first list element: List of 7
  ..$ :List of 1
  .. ..$ : num [1:15, 1:2] -88.1 -88.1 -88 -88 -88 ...
  ..$ :List of 1
  .. ..$ : num [1:9, 1:2] -88.2 -88.2 -88.2 -88.2 -88.2 ...
  ..$ :List of 1
  .. ..$ : num [1:7, 1:2] -88.2 -88.2 -88.2 -88.2 -88.2 ...
  ..$ :List of 1
  .. ..$ : num [1:57, 1:2] -88.3 -88.3 -88.3 -88.3 -88.3 ...
  ..$ :List of 1
  .. ..$ : num [1:74, 1:2] -88.3 -88.3 -88.3 -88.3 -88.3 ...
  ..$ :List of 1
  .. ..$ : num [1:17, 1:2] -88.3 -88.3 -88.3 -88.3 -88.3 ...
  ..$ :List of 1
  .. ..$ : num [1:1730, 1:2] -88.5 -88.5 -88.5 -88.5 -88.5 ...
  ..- attr(*, "class")= chr [1:3] "XY" "MULTIPOLYGON" "sfg"
 $ iso_code: chr [1:48] "US-AL" "US-AZ" "US-AR" "US-CA" ...
 - attr(*, "spec")=
  .. cols(
  ..   name = col_character(),
  ..   geometry = col_character(),
  ..   iso_code = col_character()
  .. )
 - attr(*, "problems")=&lt;externalptr&gt; 
 - attr(*, "sf_column")= chr "geometry"
 - attr(*, "agr")= Factor w/ 3 levels "constant","aggregate",..: NA NA
  ..- attr(*, "names")= chr [1:2] "name" "iso_code"</code></pre>
</div>
</div>
<p>Now, the <code>geometry</code> column has been converted into a geospatial object - a 2D Polygon. In other words, each entry on in our dataframe is now associated with a location Earth. Instead of keeping thousands of points on a graph, we group these points into geometric objects using the technique demonstrated in section 2.1. In fact, it is easy to see what we mean by this if we just plot it out:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> SQ_example[<span class="st">"name"</span>]) <span class="sc">+</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Map of the U.S. Using sf Polygons"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="vignette_files/figure-html/unnamed-chunk-13-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<section id="geospatial-dataframe-with-attributes" class="level3">
<h3 class="anchored" data-anchor-id="geospatial-dataframe-with-attributes">3.1 Geospatial Dataframe with Attributes</h3>
<p>The most important aspect of geospatial data is that we can give attributes to these individual objects. Let’s load in a dataframe consisting of invasive mammals, reptiles, and amphibians in the U.S. from 1950’s to the 2000’s.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>us_species <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(<span class="st">"data/dat_species.csv"</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>us_species <span class="ot">&lt;-</span> us_species <span class="sc">%&gt;%</span>  <span class="co"># filtering out everything we don't need.</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(year <span class="sc">&gt;=</span> <span class="st">"1950"</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(group <span class="sc">==</span> <span class="st">"Mammals"</span><span class="sc">|</span> group <span class="sc">==</span> <span class="st">"Reptiles"</span> <span class="sc">|</span> group <span class="sc">==</span> <span class="st">"Amphibians"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, normally we would perform some sort of joining operation on our <code>us_geo</code> dataframe and our <code>us_species</code> dataframe to study the relationship between invasive speices in respect to each state. However, geospatial data allows us to associate the invasive species to a location- a <code>geometry</code> object- rather than a <code>state</code> variable.</p>
<div class="cell">

</div>
<div class="cell">

</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Check the structure of SQ</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(SQ)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Classes 'sf' and 'data.frame':  1794 obs. of  19 variables:
 $ state       : chr  "Alabama" "Alabama" "Alabama" "Arizona" ...
 $ iso_code    : chr  "US-AL" "US-AL" "US-AL" "US-AZ" ...
 $ occurrence  : num  8.91e+08 6.24e+08 6.24e+08 NA 9.20e+08 ...
 $ sciname     : chr  "Myocastor coypus" "Myocastor coypus" "Myocastor coypus" NA ...
 $ kingdom     : chr  "Animal" "Animal" "Animal" NA ...
 $ group       : chr  "Mammals" "Mammals" "Mammals" NA ...
 $ family      : chr  "Myocastoridae" "Myocastoridae" "Myocastoridae" NA ...
 $ nativeregion: chr  NA NA NA NA ...
 $ centroid    : chr  "N" "N" "N" NA ...
 $ decimalLat  : num  30.7 30.8 30.7 NA 34.3 ...
 $ decimalLon  : num  -87.9 -87.8 -88.1 NA -91.4 ...
 $ dateobserved: chr  NA NA NA NA ...
 $ year        : num  2013 1956 1956 NA 1983 ...
 $ collector   : chr  "iNaturalist research-grade observations" "United States Geological Survey Nonindigenous Aquatic Species Database" "United States Geological Survey Nonindigenous Aquatic Species Database" NA ...
 $ recordedBy  : chr  "Michael P. Riggs" NA NA NA ...
 $ huc8skm     : num  2363 2384 2363 NA 3524 ...
 $ huc10skm    : num  393 672 393 NA 343 ...
 $ huc12skm    : num  150.3 128 76.9 NA 87.1 ...
 $ geometry    :sfc_GEOMETRY of length 1794; first list element: List of 7
  ..$ :List of 1
  .. ..$ : num [1:15, 1:2] -88.1 -88.1 -88 -88 -88 ...
  ..$ :List of 1
  .. ..$ : num [1:9, 1:2] -88.2 -88.2 -88.2 -88.2 -88.2 ...
  ..$ :List of 1
  .. ..$ : num [1:7, 1:2] -88.2 -88.2 -88.2 -88.2 -88.2 ...
  ..$ :List of 1
  .. ..$ : num [1:57, 1:2] -88.3 -88.3 -88.3 -88.3 -88.3 ...
  ..$ :List of 1
  .. ..$ : num [1:74, 1:2] -88.3 -88.3 -88.3 -88.3 -88.3 ...
  ..$ :List of 1
  .. ..$ : num [1:17, 1:2] -88.3 -88.3 -88.3 -88.3 -88.3 ...
  ..$ :List of 1
  .. ..$ : num [1:1730, 1:2] -88.5 -88.5 -88.5 -88.5 -88.5 ...
  ..- attr(*, "class")= chr [1:3] "XY" "MULTIPOLYGON" "sfg"
 - attr(*, "sf_column")= chr "geometry"
 - attr(*, "agr")= Factor w/ 3 levels "constant","aggregate",..: NA NA NA NA NA NA NA NA NA NA ...
  ..- attr(*, "names")= chr [1:18] "state" "iso_code" "occurrence" "sciname" ...</code></pre>
</div>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">unique</span>(us_geo_merged<span class="sc">$</span>sciname)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "Myocastor coypus"               NA                              
 [3] "Hydrochoerus hydrochaeris"      "Osteopilus septentrionalis"    
 [5] "Eleutherodactylus planirostris" "Caiman crocodilus"             
 [7] "Acrochordus javanicus"          "Eunectes notaeus"              
 [9] "Xenopus laevis"                 "Bombina orientalis"            </code></pre>
</div>
</div>
<p>Again, the <code>geometry</code> column is consisted of a “sf” object; whereas previously, it was a state with a vector of coordinates. However, each data entry is also given a collection of attributes such as <code>sciname</code>, <code>kingdom</code>, <code>occurrence</code>, and etc. Let’s see how we can reference these attributes within each state (“sf” object). Within our <code>us_species</code> data frame, there is a species named <code>Hydrochoerus hydrochaeris</code> more commonly known as the capybara.</p>
<p><img src="images/capybara-square-1.jpg.optimal.jpg" class="img-fluid" width="500"></p>
<p>By indexing on species name, we can reference the capybara directly by location of the “sf” objects.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>SQ_f <span class="ot">&lt;-</span> SQ <span class="sc">%&gt;%</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(sciname <span class="sc">==</span> <span class="st">"Hydrochoerus hydrochaeris"</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(year <span class="sc">&lt;=</span> <span class="dv">2015</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(state) <span class="sc">%&gt;%</span> </span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarise</span>(<span class="at">occurrence =</span> <span class="fu">sum</span>(occurrence))</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Create a ggplot object</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Add the filtered sf object as a layer</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> SQ1[<span class="st">"state"</span>]) <span class="sc">+</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data =</span> SQ_f, <span class="fu">aes</span>(<span class="at">fill =</span> occurrence)) <span class="sc">+</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Customize the plot as needed</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Occurrences Plot"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="vignette_files/figure-html/unnamed-chunk-18-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>As one can see, “sf” objects are extremely great in the context of visualization. Each location is treated as an individual data point; thus, we are filtering and parsing the data in terms of the locations themselves. In order to demonstrate this, we have created a simple <a href="https://yibster.shinyapps.io/gisshinyapp/">ShinyApp</a> to illustrate the use of geospatial data structures in data visualization.</p>
</section>
</section>
<section id="modeling-with-geospatial-data-spatial-poisson-model" class="level2">
<h2 class="anchored" data-anchor-id="modeling-with-geospatial-data-spatial-poisson-model">4. Modeling with Geospatial Data: Spatial Poisson Model</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(sf)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spdep)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can predict the number appearances of a species using spatial poisson model. Here we will explain how it works and provide some example codes about the model building, you can copy and paste them to try!</p>
<section id="model-preparation" class="level3">
<h3 class="anchored" data-anchor-id="model-preparation">4.1 Model Preparation</h3>
<p>First, we use spatial weights matrix to represent the relationships between states. The matrix captures the neighbor states of the state we want to predict on, and their correlation:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create spatial weights matrix  </span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>w <span class="ot">&lt;-</span> <span class="fu">knn2nb</span>(<span class="fu">knearneigh</span>(<span class="fu">st_coordinates</span>(your_dataset)))  </span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>W <span class="ot">&lt;-</span> <span class="fu">nb2listw</span>(w)<span class="st">`</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>st_coordinates()</code>: This extracts the coordinates from the ‘geometry’ column of the <strong><code>your_dataset</code></strong>. It gives a matrix containing the X and Y coordinates for each observation. If you have points, these will be the point coordinates; if you have polygons, these will be the centroid coordinates.</p>
<p><code>knearneigh()</code>: This function computes the k-nearest neighbors for each point based on Euclidean distance. It returns a “knn” object that represents the k-nearest neighbors relationships. The <strong><code>k</code></strong> parameter is not specified in this code.</p>
<p><code>nb2listw()</code>: This function converts the knn object into a spatial weights matrix using a k-nearest neighbor rule. It creates a binary spatial weights matrix where neighboring points are considered neighbors. The resulting object <strong><code>w</code></strong> is a representation of the neighborhood relationships among the observations.</p>
</section>
<section id="model-building" class="level3">
<h3 class="anchored" data-anchor-id="model-building">4.2 Model Building</h3>
<p>Now, we can fit a spatial Poisson on the dataset</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>spatial_poisson_model <span class="ot">&lt;-</span> <span class="fu">errorsarlm</span>(count <span class="sc">~</span> <span class="dv">1</span>, <span class="at">data =</span> frog_data_sf, <span class="at">W =</span> W, <span class="at">family =</span> poisson)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong><code>W = W:</code></strong> It means the spatial weights matrix to account for spatial autocorrelation, in this case W is generated from knn.</p>
</section>
<section id="prediction" class="level3">
<h3 class="anchored" data-anchor-id="prediction">4.3 Prediction</h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Predict occurrences using the spatial Poisson model</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>predictions <span class="ot">&lt;-</span> <span class="fu">predict</span>(spatial_poisson_model, <span class="at">newdata =</span> new_data, <span class="at">type =</span> <span class="st">"response"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For more information, refer to this link:</p>
<p><a href="https://apwheele.github.io/Class_CrimeMapping/08_Tutorial_R_SpatRegression.html" class="uri">https://apwheele.github.io/Class_CrimeMapping/08_Tutorial_R_SpatRegression.html</a></p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">5. Conclusion</h2>
<p>In conclusion, this vignette introduced the geospatial data structure, the “sf” package in R, and modeling for geospatial data. The document provides insights into creating “sf” objects, emphasizing their capacity to incorporate both geometric and attribute data. It compares two methods: cluster grouping condenses border data into 2D polygons, while centroid polygons isolate data points in dense clusters by drawing an area around each centroid. Real-world applications include constructing a 2D polygon map of the U.S., showcasing the efficiency of geospatial data structures in visualization and data association. In our example of invasive species in the U.S., we showed how geospatial data allows us to associated the invasive species to a location with a high dimensional vector object, and how to visualize the result. In the end, we provided a simple example of building Poisson model for predicting counts in a specific location using geospatial data structure. As geospatial data structures may be unfamiliar to many, we briefly touched on modeling, but we invite you to enhance your understanding by creating and experimenting with a simple geospatial dataset.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>