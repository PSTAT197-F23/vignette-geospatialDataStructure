---
title: "An Introdution to Geospatial Data Structures"
author: 'Yibo Liang, Pippa Lin, Chris Zhao'
date: December 3, 2023
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

## 1.1 The "sf" Package

The R-package we will be using for this demonstration is the "sf" package. It adopts the "Simple Features" formal standard, outlining a storage and access model for spatial geometries such as points, lines, and polygons. A geometry is considered simple when it comprises points connected by straight line segments and avoids self-intersections.

```{r, results='hide'}
library(sf)
library(tidyverse)
library(tidymodels)
library(ggplot2)
library(dplyr)
library(ggmap)
library(leaflet) 
```

## 1.2 Basic Spatial Structures in "sf"

Some of the basic spatial objects that are in the "sf" package for dealing with vector spatial data include:

-   points

-   lines

-   polygons

![](images/geomtry.png)

A simple feature object is stored as a "sf" object. The image above is a visualization of the "sf" objects.s

### 1.2.1 Creating a "sf" object

Let's create an example "sf" line object. A line object is characterized by points in some coordinate space and connected by a chord we call line.

First, we will define the lines themselves with `st_linestring()`

```{r}
lnstr_sfg1 <- st_linestring(matrix(runif(10), ncol=2)) # a line with 10 points
lnstr_sfg2 <- st_linestring(matrix(runif(10), ncol=2)) # ncol = 2 specifies the dimension
```

Next, we will combine the two lines into a single feature before transforming it into a single "sf" object.

```{r}
(lnstr_sfc <- st_sfc(lnstr_sfg1, lnstr_sfg2)) # just one feature here
```

Now that we have 2 lines combined into a single feature, we haven't actually assigned any meaning to the 2 lines yet. Let's give them some attributes! Let's pretend that these two lines are a highway and we they each have an attribute \`car_per_hour\` describing the number of cars that travels through them every hour.

```{r}
dfr <- data.frame(id = c("hwy1", "hwy2"),
                  cars_per_hour = c(78, 22)) 
(lnstr_sf <- st_sf(dfr , lnstr_sfc)) # 2 lines each with an attribute cars_per_hour
```

Now we have a data-frame that associates an attribute to a spatial structure rather than another data point!

```{r}
ggplot() +
  geom_sf(data = lnstr_sf["id"]) +
    theme_minimal()
```

## 2.1 Using sf Objects to Record GeoSpatial Data

Now that we understand how to create a sf object; let's demonstrate an sf object that contains geospatial meaning. Let's take 3 clusters of points a, b, and c and showcase the utility of the sf object.

```{r, echo=FALSE}
a_lat <- c(72.117, 71.05, 71.717, 71.167, 71.817, 72.333, 71.25, 70.917, 
  70.85, 70.933)
a_lon <- c(33.217, 30.333, 26.3, 22.333, 22.333, 22.333, 18.517, 20.133, 
             21.333, 19.917)
b_lat <- c(41.283333, 41, 40.95, 40.95, 38.683333, 40.783333, 40.733333, 
            40.516667, 38.566667, 41.266667)
b_lon <- c(-71.116667, -70.733333, -70.583333, -70.483333, -74.816667, 
            -70.5, -70.566667, -70.266667, -74.85, -71.366667)
c_lat <- c(58.015, 57.67167, 57.33833, 56.685, 56.99333, 57.31667, 57.65, 
            57.99667, 58.32167, 58.33333)
c_lon <- c(-158.31667, -158.36, -158.41, -159.76, -159.72333, -159.66333, 
            -159.64167, -159.605, -159.54, -160.72167)
a_dat <- data.frame(lat=a_lat, lon=a_lon)
b_dat <- data.frame(lat=b_lat, lon=b_lon)
c_dat <- data.frame(lat=c_lat, lon=c_lon)
a_dat$cluster <- "a"
b_dat$cluster <- "b"
c_dat$cluster <- "c"
dat <- rbind(a_dat, b_dat, c_dat)

```

```{r}
ggplot(dat, aes(x = lon, y = lat, color = cluster)) +
  geom_point() +
  labs(title = "Scatter Plot of Clusters",
       x = "Lon",
       y = "Lat")
```

Looking at the points above, there is clear some implicit relationship between the point clusters. However, it would be incredibly difficult to identify the cluster if there were more points and more variables.![](images/800px-RTree-Visualization-3D.svg.png)

Location gets increasingly difficult to keep track of as we get higher and higher dimensions in our dataframe. In fact, if the variables are in $$\mathbb{R}^n$$ then points will be n-dimensional, lines will be $$n^2$$-dimensional, and n-dimensional geometries will be $$n^n$$ dimensional. The dimension will get out of hand extremely quickly. Therefore, instead of keeping every coordinate of the location, we can keep the geometries themselves as objects in the dataframe.

Going back to the previous example, using the sf package, we can then treat these cluster points as coordinate points and draw a polygon.

```{r}
shapes <- dat %>%
  st_as_sf(coords = c("lon", "lat")) %>%
  group_by(cluster) %>%
  summarize(geometry = st_union(geometry)) %>%
  st_convex_hull()
plot(shapes)
```

Originally, we had 30 data points each with 2 dimensions. After converting these data points into "sf" objects, we only have 3 data point; however, each data point contains 10 locations.

## 2.2 Using the sf Object on a GeoSpatial Dataframe

Using everything we've discussed so far, let's draw a geospatial map. First we will load in a vector of coordinates.

```{r, echo=FALSE}
us_geo <- read_csv("data/dat_spatial.csv")
us_geo <- us_geo %>% 
  filter(name != "Hawaii" & name != "Alaska")
```

```{r}
us_geo
```

What we have just loaded in is a dataframe containing the 48 States (Sorry Hawaii and Alaska) and their latitudes and longitudes of points along their perimeter.

However, a vector of coordinates is hard to interpretate. Therefore, we can convert this vector data into geospatial data by creating a "sf" object.

```{r}
SQ_example <- st_as_sf(us_geo, wkt = "geometry")
str(SQ_example)
```

Now, the `geometry` column has been converted into a geo spatial object. The reason why we want to use geospatial objects when dealing with geospatial data is instead of associating every state with a bunch of coordinate points, we give each state one geospatial object. In other words, each entry on in our dataframe is now associated with a location Earth. Instead of keeping thousands of points on a graph, we group these points into geometric objects using the technique demonstrated in section 2.1. In fact, it is easy to see if we just plot it out:

```{r}
ggplot() +
  geom_sf(data = SQ_example["name"]) +
    theme_minimal() +
    labs(title = "Map of the U.S. Using sf Polygons")

```

Here, we want to stress how powerful geospatial data structures are when we want to perform visualizations. It takes a significantly less amount of computing power to plot 58 objects as compared to plotting hundreds of thousands of data points/

## 3.1 Geospatial Dataframe with Attributes

The most important aspect of geospatial data is that we can give attributes to these individual objects. Let's load in a dataframe consisting of invasive mammals, reptiles, and amphibians in the U.S. from 1950's to the 2000's.

```{r}
us_species <- read_csv("data/dat_species.csv")
us_species <- us_species %>%  # filtering out everything we don't need.
  filter(year >= "1950") %>% 
  filter(group == "Mammals"| group == "Reptiles" | group == "Amphibians")
```

Now, normally we would normally perform some sort of joining operation on our `us_geo` dataframe and and `us_species` dataframe to study the relationship between invasive speices in respect to each state. However, geospatial data allows us to associated the invasive species to a location rather than a `state` variable with a high dimensional vector object.

```{r, echo=FALSE, results='hide'}
colnames(us_geo)[1] <- "state"
us_geo_merged <- merge(us_geo,us_species,by="state", all=T)
names(us_geo_merged) 
```

```{r, echo=FALSE}
us_geo_merged <- us_geo_merged[is.na(us_geo_merged$geometry) == FALSE, ]

# Create an sf object (SQ) from the WKT geometries
SQ <- st_as_sf(us_geo_merged, wkt = "geometry")
SQ1 <- st_as_sf(us_geo, wkt = "geometry")
```

```{r}
# Check the structure of SQ
str(SQ)
unique(us_geo_merged$sciname)
```

Notice, the `geometry` column is consisted of a "sf" object whereas previously, it was a state with a vector of coordinates. However, each data entry is also given a collection of attributes such as `sciname`, `kingdom`, `occurrence`, and etc. Let's see how we can reference these attributes within each state ("sf" object). Within our `us_species` data frame, there is a species named `Hydrochoerus hydrochaeris` more commonly known as the capybara.

![](images/capybara-square-1.jpg.optimal.jpg){width="500"}

By indexing on species name, we can reference the capybara directly by location in the "sf" objects.

```{r}
SQ_f <- SQ %>%
  filter(sciname == "Hydrochoerus hydrochaeris") %>% 
  filter(year <= 2015) %>% 
  group_by(state) %>% 
  summarise(occurrence = sum(occurrence))

  # Create a ggplot object
ggplot() +
  # Add the filtered sf object as a layer
  geom_sf(data = SQ1["state"]) +
  geom_sf(data = SQ_f, aes(fill = occurrence)) +
        
  # Customize the plot as needed
  theme_minimal() +
    labs(title = "Occurrences Plot")
```

As one can see the prowess of "sf" objects is extremely great in the context of visualization. Each location is treated as an individual data point; thus, we are filtering and parse the data in terms of the locations themselves. In addition to having a structural advantage compared to their vector counter parts, the time it takes to process "sf" objects is also significantly faster. In order to demonstrate this, we have created a simple [ShinyApp](https://yibster.shinyapps.io/gisshinyapp/) to illustrate the use of geospatial data structures in data visualization.

## 4.1 Modeling with Geospatial Data: Spatial Poisson Model

```{r}
library(sf)
library(spdep)
library(ggplot2)
```

We can predict the number appearances of a species using spatial poisson model. Here we will explain how it works and provide some example codes about the model building, you can copy and paste them to try!

### 4.1.2 Model Preparation

First, we use spatial weights matrix to represent the relationships between states. The matrix captures the neighbor states of the state we want to predict on, and their correlation:

`{r. eval = FALSE} # Create spatial weights matrix  w <- knn2nb(knearneigh(st_coordinates(your_dataset)))  W <- nb2listw(w)`

`st_coordinates()`: This extracts the coordinates from the 'geometry' column of the **`your_dataset`**. It gives a matrix containing the X and Y coordinates for each observation. If you have points, these will be the point coordinates; if you have polygons, these will be the centroid coordinates.

`knearneigh()`: This function computes the k-nearest neighbors for each point based on Euclidean distance. It returns a "knn" object that represents the k-nearest neighbors relationships. The **`k`** parameter is not specified in this code.

`nb2listw()`: This function converts the knn object into a spatial weights matrix using a k-nearest neighbor rule. It creates a binary spatial weights matrix where neighboring points are considered neighbors. The resulting object **`w`** is a representation of the neighborhood relationships among the observations.

### 4.1.2 Model Building

Now, we can fit a spatial Poisson on the dataset

```{r,  eval = FALSE}
spatial_poisson_model <- errorsarlm(count ~ 1, data = frog_data_sf, W = W, family = poisson)
```

**`W = W:`** It means the spatial weights matrix to account for spatial autocorrelation, in this case W is generated from knn.

### 4.1.3 Prediction

```{r,  eval = FALSE}
# Predict occurrences using the spatial Poisson model
predictions <- predict(spatial_poisson_model, newdata = new_data, type = "response")
```

More information:

<https://apwheele.github.io/Class_CrimeMapping/08_Tutorial_R_SpatRegression.html>

## 4.2 Modeling on Our Capybara Data
